<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gooblet Sandbox</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { border: 1px solid #888; display: block; margin: auto; cursor: none; background: #f9f9f9; }
    #gui {
      position: fixed; top: 0; right: 0; width: 300px; height: 100vh;
      background: #fff; overflow-y: auto; border-left: 2px solid #ccc; padding: 10px;
    }
    h2 { margin-top: 0; }
    .editor-section { margin-bottom: 15px; }
    #mat-preview { width: 50px; height: 50px; margin-top: 10px; border-radius: 5px; border: 1px solid #ccc; }
    .button-group button { margin: 5px 5px 0 0; }
  </style>
</head>
<body>
  <canvas id="canvas" width="800" height="600"></canvas>
  <div id="gui">
    <h2>ðŸŽ¨ Custom Material Editor</h2>
    <div class="editor-section">
      <label>Name: <input type="text" id="mat-name" /></label>
    </div>
    <div class="editor-section">
      <label>Color: <input type="color" id="mat-color" /></label>
      <div id="mat-preview"></div>
    </div>
    <div class="editor-section">
      <label>Density: <input type="range" id="mat-density" min="0" max="100" /></label>
    </div>
    <div class="editor-section">
      <label>Flammability: <input type="range" id="mat-flame" min="0" max="100" /></label>
    </div>
    <div class="editor-section">
      <label>State:
        <select id="mat-state">
          <option value="solid">Solid</option>
          <option value="liquid">Liquid</option>
          <option value="gas">Gas</option>
          <option value="powder">Powder</option>
        </select>
      </label>
    </div>
    <div class="button-group">
      <button onclick="saveMaterial()">Save Material</button>
      <button onclick="undo()">Undo</button>
      <button onclick="redo()">Redo</button>
      <button onclick="saveScene()">ðŸ’¾ Save</button>
      <button onclick="loadScene()">ðŸ“‚ Load</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const preview = document.getElementById("mat-preview");

    let materials = [];
    let points = [];
    let undoStack = [];
    let redoStack = [];

    const VILLAGE_CENTER = { x: 400, y: 300 };

    class Particle {
      constructor(x, y, material) {
        this.x = x;
        this.y = y;
        this.material = material;
      }
    }

    function saveMaterial() {
      const name = matName().toLowerCase();
      const color = document.getElementById("mat-color").value;
      const density = +document.getElementById("mat-density").value;
      const flame = +document.getElementById("mat-flame").value;
      const state = document.getElementById("mat-state").value;

      materials.push({ name, color, density, flammability: flame, state });
      alert("Material '" + name + "' saved.");
    }

    function getPixel(x, y) {
      return points.find(p => p.x === x && p.y === y);
    }

    function scan(p, range, targetName) {
      for (let dx = -range; dx <= range; dx++) {
        for (let dy = -range; dy <= range; dy++) {
          const tx = p.x + dx;
          const ty = p.y + dy;
          const test = getPixel(tx, ty);
          if (test && materials[test.material].name === targetName) {
            return test;
          }
        }
      }
      return null;
    }

    function updateGooblet(p) {
      const fire = scan(p, 10, "fire");
      const water = scan(p, 15, "water");
      const buddy = scan(p, 5, "gooblet");

      if (fire) {
        p.x += Math.sign(p.x - fire.x);
        p.y += Math.sign(p.y - fire.y);
      } else if (water) {
        materials[water.material].density = Math.max(0, materials[water.material].density - 1);
      } else if (buddy) {
        p.x += Math.sign(buddy.x - p.x);
        p.y += Math.sign(buddy.y - p.y);
      } else {
        p.x += Math.sign(VILLAGE_CENTER.x - p.x);
        p.y += Math.sign(VILLAGE_CENTER.y - p.y);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points.forEach(p => {
        const m = materials[p.material];
        ctx.fillStyle = m.color;
        ctx.fillRect(p.x, p.y, 3, 3);
        if (m.name === "gooblet") updateGooblet(p);
      });
    }

    function tick() {
      draw();
      requestAnimationFrame(tick);
    }

    function undo() {
      if (undoStack.length) {
        redoStack.push([...points]);
        points = undoStack.pop();
      }
    }

    function redo() {
      if (redoStack.length) {
        undoStack.push([...points]);
        points = redoStack.pop();
      }
    }

    function saveScene() {
      localStorage.setItem("goob-scene", JSON.stringify(points));
      alert("Scene saved.");
    }

    function loadScene() {
      const data = localStorage.getItem("goob-scene");
      if (data) {
        points = JSON.parse(data);
        alert("Scene loaded.");
      }
    }

    function matName() {
      return document.getElementById("mat-name").value;
    }

    preview.style.backgroundColor = document.getElementById("mat-color").value;
    document.getElementById("mat-color").addEventListener("input", e => {
      preview.style.backgroundColor = e.target.value;
    });

    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor(e.clientX - rect.left);
      const y = Math.floor(e.clientY - rect.top);
      const currentMat = materials.find(m => m.name === matName().toLowerCase());
      if (!currentMat) {
        alert("Select or create a material first.");
        return;
      }

      undoStack.push([...points]);
      points.push(new Particle(x, y, materials.indexOf(currentMat)));
    });

    tick();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gooblet Sandbox</title>
  <style>
    body { margin: 0; font-family: sans-serif; background: #111; color: #eee; }
    canvas { display: block; margin: auto; background: black; }
    #toolbar, #editor { padding: 1em; background: #222; text-align: center; }
    button, input, select { margin: 0.25em; }
    #editor { display: none; border-top: 1px solid #444; }
  </style>
</head>
<body>
  <canvas id="canvas" width="400" height="400"></canvas>

  <div id="toolbar">
    <button onclick="toggleEditor()">🧪 Edit Materials</button>
    <button onclick="downloadScene()">⬇️ Download</button>
    <button onclick="saveLocal()">💾 Save</button>
    <button onclick="loadScene()">📂 Load</button>
    <button onclick="undo()">Undo</button>
  </div>

  <div id="editor">
    <h3>Material Editor</h3>
    Name: <input id="matName">
    Color: <input type="color" id="matColor">
    Density: <input type="number" id="matDensity">
    Flammability: <input type="number" id="matFlame">
    State:
    <select id="matState">
      <option value="solid">Solid</option>
      <option value="liquid">Liquid</option>
      <option value="powder">Powder</option>
    </select>
    <button onclick="saveMaterial()">Save Material</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let points = [], history = [], materials = {};

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      points.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 2, 2);
      });
    }

    function simulate() {
      points.forEach(p => {
        const mat = materials[p.material];
        if (!mat) return;
        if (mat.state === "liquid" || mat.state === "powder") {
          p.y = Math.min(p.y + 1, canvas.height - 2);
        }
      });
    }

    function tick() {
      simulate();
      draw();
      requestAnimationFrame(tick);
    }

    function toggleEditor() {
      const editor = document.getElementById("editor");
      editor.style.display = editor.style.display === "none" ? "block" : "none";
    }

    function saveMaterial() {
      const name = matName.value.trim();
      if (!name) return alert("Material needs a name.");
      materials[name] = {
        color: matColor.value,
        density: parseFloat(matDensity.value),
        flammability: parseFloat(matFlame.value),
        state: matState.value
      };
      alert(`Material "${name}" saved.`);
    }

    function downloadScene() {
      const blob = new Blob([JSON.stringify(points)], { type: "application/json" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "gooblet-scene.json";
      link.click();
    }

    function saveLocal() {
      localStorage.setItem("goobletScene", JSON.stringify(points));
      alert("Saved to localStorage.");
    }

    function loadScene() {
      const data = localStorage.getItem("goobletScene");
      if (data) {
        points = JSON.parse(data);
        alert("Scene loaded.");
      }
    }

    function undo() {
      if (history.length > 0) {
        points = history.pop();
        draw();
      }
    }

    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor(e.clientX - rect.left);
      const y = Math.floor(e.clientY - rect.top);
      const matKeys = Object.keys(materials);
      if (matKeys.length === 0) return alert("Create a material first!");
      const mat = materials[matKeys[0]]; // default to first material
      history.push([...points]);
      points.push({ x, y, color: mat.color, material: matKeys[0] });
    });

    tick();
  </script>
</body>
</html>
